import { io } from "socket.io-client";

const API = (typeof import.meta !== "undefined" const API const API  import.meta.env?.VITE_API_BASE) || "/";

const WS_TOKEN = (typeof import.meta !== 'undefined' const API const API  import.meta.env?.VITE_WS_TOKEN) || (typeof localStorage !== 'undefined' ? localStorage.getItem('KUMA_WS_TOKEN') : null);
const onAnyLog = (socket, forward) => { if (!socket || !socket.onAny) return; socket.onAny((ev, ...args) => { const payload = (args const API const API  args.length ? args[0] : undefined); try { console.info('[kuma-ws:any]', ev, payload); } catch(e){} try { if (forward) forward(payload); } catch(e){} }); };= (typeof import.meta !== "undefined" const API const API  import.meta.env?.VITE_API_BASE) || "/";

const WS_TOKEN = (typeof import.meta !== 'undefined' const API const API  import.meta.env?.VITE_WS_TOKEN) || (typeof localStorage !== 'undefined' ? localStorage.getItem('KUMA_WS_TOKEN') : null);
const onAnyLog = (socket) => { if (!socket || !socket.onAny) return; socket.onAny((ev, ...args) => { try { console.info('[kuma-ws:any]', ev, Array.isArray(args)? args[0] : args); } catch(e){} }); };= (typeof import.meta !== "undefined" && import.meta.env?.VITE_API_BASE) || "/";

const log  = (...a) => console.info("[kuma-api]", ...a);
const warn = (...a) => console.warn("[kuma-api]", ...a);
const err  = (...a) => console.error("[kuma-api]", ...a);

async function fetchJSON(path, init = {}) {
  const res = await fetch(API + path, {
    headers: { "Accept": "application/json", ...(init.headers || {}) },
    ...init,
  });
  if (!res.ok) {
    const text = await res.text().catch(() => "");
    throw new Error(`HTTP ${res.status} ${res.statusText} - ${text}`);
  }
  return res.json();
}

export async function fetchSummary() {
  const r = await fetchJSON("api/summary");
  log("summary OK");
  return r;
}

export async function fetchMonitors() {
  const candidates = [
    "api/monitors", "api/monitor", "api/monitor/list",
    "api/monitors/list", "api/state", "monitors",
  ];
  for (const p of candidates) {
    try {
      const r = await fetchJSON(p);
      const arr = Array.isArray(r)
        ? r
        : Array.isArray(r?.monitors)
          ? r.monitors
          : Array.isArray(r?.data?.monitors)
            ? r.data.monitors
            : null;
      if (arr) { log("monitors OK via", p, `(${arr.length})`); return arr; }
      warn("monitors shape inesperada en", p, r);
    } catch (e) {
      log("monitors no en", p, "-", (e && e.message) || e);
    }
  }
  warn("Ninguna ruta de 'monitors' respondió. Se esperará a WS/SSE.");
  return [];
}

function pickMonitors(p) {
  if (!p) return [];
  if (Array.isArray(p)) return p;
  if (Array.isArray(p.monitors)) return p.monitors;
  if (Array.isArray(p?.data?.monitors)) return p.data.monitors;
  if (Array.isArray(p?.payload?.monitors)) return p.payload.monitors;
  if (Array.isArray(p.items)) return p.items;
  return [];
}

export function openStream(onMessage, { retryMs = 2000, maxRetryMs = 15000 } = {}) {
  // ===== 1) WebSocket (Socket.IO) primero =====
  try {
    const base = (typeof import.meta !== "undefined" && import.meta.env?.VITE_API_BASE)
      ? import.meta.env.VITE_API_BASE.replace(/\/$/, "")
      : ""; // vacío → relativo al dev server (proxy)

    const socket = io(base || undefined, {
      path: "/socket.io",
      transports: ["websocket"],
      withCredentials: true,
      auth: WS_TOKEN ? { token: WS_TOKEN } : undefined,
      query: WS_TOKEN ? { token: WS_TOKEN } : undefined,
    });

    socket.on("connect", () => log("WS conectado", socket.id));

    // Logs de error + captura de cualquier evento y reenvío al onMessage
    socket.on("connect_error", (e)=> warn("WS connect_error:", e && (e.message || e)));
    socket.on("error", (e)=> warn("WS error:", e));
    onAnyLog(socket, (payload)=>{ try { onMessage?.(payload); } catch(e){} });
    // Si el backend exige handshake de auth/subscripción, lo intentamos (si hay token)
    if (WS_TOKEN) {
      try { socket.emit("auth", { token: WS_TOKEN }); } catch {}
      try { socket.emit("subscribe", { token: WS_TOKEN }); } catch {}
    }

    // Logs de error y de cualquier evento recibido
    socket.on("connect_error", (e)=> warn("WS connect_error:", e && (e.message || e)));
    socket.on("error", (e)=> warn("WS error:", e));
    onAnyLog(socket);
    // Si el backend exige emits iniciales, descomenta y ajusta:
    if (WS_TOKEN) {
      try { socket.emit("auth", { token: WS_TOKEN }); } catch {}
      try { socket.emit("subscribe", { token: WS_TOKEN }); } catch {}
    }

    ["tick", "monitors", "message", "data"].forEach(ev =>
      socket.on(ev, (payload) => {
        log(`WS '${ev}' recibido`);
        try { onMessage?.(payload); }
        catch(e){ err("onMessage error:", e); }
      })
    );

    socket.on("disconnect", (reason) => warn("WS desconectado:", reason));

    // Si WS funciona, devolvemos su close y listo.
    return () => { try { socket.close(); } catch {} };
  } catch (e) {
    warn("WS init error, fallback a SSE:", e);
  }

  // ===== 2) Fallback SSE =====
  const PATHS = ["/stream", "/api/stream", "/api/sse", "/events"];
  let stopped = false, es = null, pathIdx = 0, backoff = retryMs, received = false;

  const attach = () => {
    const handler = (label, e) => {
      try { onMessage?.(JSON.parse(e.data)); }
      catch (err2) { warn("SSE parse err", label, err2); }
    };
    es.addEventListener("tick",    (e)=>handler("tick", e));
    es.addEventListener("message", (e)=>handler("message", e));
    es.onmessage = (e)=>handler("onmessage", e);
  };

  const tryNext = () => {
    if (stopped) return;
    if (pathIdx >= PATHS.length) {
      setTimeout(() => {
        if (!stopped) { pathIdx = 0; backoff = Math.min(backoff * 2, maxRetryMs); start(); }
      }, backoff);
      return;
    }
    start();
  };

  const start = () => {
    const path = PATHS[pathIdx]; received = false;
    try { log("SSE intentando", path); es = new EventSource(API + path); }
    catch (e) { warn("EventSource init err:", e); pathIdx++; return tryNext(); }

    const watchdog = setTimeout(() => {
      if (!received) { warn("SSE sin datos en", path, "→ siguiente"); es.close(); pathIdx++; tryNext(); }
    }, 5000);

    es.onopen = () => log("SSE abierto en", path);
    es.onerror = () => { clearTimeout(watchdog); es?.close?.(); if (!stopped) { warn("SSE error", path, "→ siguiente"); pathIdx++; tryNext(); } };
    attach();
  };

  start();
  return () => { stopped = true; try { es?.close?.(); } catch {} };
}

const BL_KEY = "kuma_blocklist_v1";
export async function getBlocklist() {
  try {
    const r = await fetchJSON("api/blocklist");
    log("blocklist server OK");
    return r;
  } catch (e) {
    try {
      const raw = localStorage.getItem(BL_KEY);
      return raw ? JSON.parse(raw) : { monitors: [] };
    } catch {
      return { monitors: [] };
    }
  }
}
export async function saveBlocklist(b) {
  try {
    await fetchJSON("api/blocklist", {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(b),
    });
    log("blocklist server guardado");
  } catch (e) {
    try { localStorage.setItem(BL_KEY, JSON.stringify(b)); }
    catch (e2) { err("no se pudo guardar blocklist", e2); }
  }
}
