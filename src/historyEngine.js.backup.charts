import { historyApi } from './services/historyApi.js';

// Cache local como fallback (mantiene compatibilidad)
let localCache = {
  data: {},
  lastUpdate: 0,
  CACHE_DURATION: 5000 // 5 segundos
};

// Función para convertir datos de la API al formato esperado por el frontend
function convertApiToPoint(data) {
  if (!data || !Array.isArray(data)) return [];
  
  return data.map(item => {
    const point = {
      ts: item.timestamp,
      ms: item.avgResponseTime || 0,
      sec: (item.avgResponseTime || 0) / 1000,
      x: item.timestamp,
      y: (item.avgResponseTime || 0) / 1000,
      value: (item.avgResponseTime || 0) / 1000,
      avgMs: item.avgResponseTime || 0,
      status: item.avgStatus > 0.5 ? 'up' : 'down'
    };
    
    point.xy = [point.x, point.y];
    return point;
  });
}

// Función para construir monitorId (igual que en el backend)
function buildMonitorId(instance, name) {
  return `${instance}_${name}`.replace(/\s+/g, '_');
}

const History = {
  /**
   * Obtener serie para un monitor específico
   * @param {string} instance - Nombre de la instancia
   * @param {string} name - Nombre del monitor
   * @param {number} sinceMs - Milisegundos hacia atrás (default: 60 minutos)
   * @returns {Promise<Array>} Array de puntos
   */
  async getSeriesForMonitor(instance, name, sinceMs = 60 * 60 * 1000) {
    try {
      const monitorId = buildMonitorId(instance, name);
      console.log(`[HIST] Fetching from API: ${monitorId}, last ${Math.round(sinceMs/1000/60)}min`);
      
      const apiData = await historyApi.getSeriesForMonitor(monitorId, sinceMs, 60000);
      
      if (apiData && apiData.length > 0) {
        console.log(`[HIST] API returned ${apiData.length} data points for ${monitorId}`);
        return convertApiToPoint(apiData);
      } else {
        console.log(`[HIST] No API data for ${monitorId}, using fallback`);
        // Fallback: datos de ejemplo (mantiene gráfica visible)
        return this._generateFallbackData(sinceMs);
      }
    } catch (error) {
      console.error('[HIST] getSeriesForMonitor error:', error);
      return this._generateFallbackData(sinceMs);
    }
  },

  /**
   * Obtener serie promediada por instancia
   * @param {string} instance - Nombre de la instancia
   * @param {number} sinceMs - Milisegundos hacia atrás
   * @param {number} bucketMs - Tamaño de bucket
   * @returns {Promise<Array>} Array de puntos
   */
  async getAvgSeriesByInstance(instance, sinceMs = 60 * 60 * 1000, bucketMs = 60000) {
    try {
      console.log(`[HIST] Fetching avg series for instance: ${instance}`);
      
      const apiData = await historyApi.getAvgSeriesByInstance(instance, sinceMs, bucketMs);
      
      if (apiData && apiData.length > 0) {
        console.log(`[HIST] API returned ${apiData.length} avg points for ${instance}`);
        return convertApiToPoint(apiData);
      } else {
        console.log(`[HIST] No API avg data for ${instance}, using fallback`);
        return this._generateFallbackData(sinceMs);
      }
    } catch (error) {
      console.error('[HIST] getAvgSeriesByInstance error:', error);
      return this._generateFallbackData(sinceMs);
    }
  },

  /**
   * Obtener todos los datos de una instancia
   * @param {string} instance - Nombre de la instancia
   * @param {number} sinceMs - Milisegundos hacia atrás
   * @returns {Promise<Object>} Datos de la instancia
   */
  async getAllForInstance(instance, sinceMs = 60 * 60 * 1000) {
    try {
      console.log(`[HIST] Fetching all data for instance: ${instance}`);
      
      const apiData = await historyApi.getAllForInstance(instance, sinceMs);
      
      if (apiData && Object.keys(apiData).length > 0) {
        console.log(`[HIST] API returned data for ${instance}`);
        return apiData;
      } else {
        console.log(`[HIST] No API data for ${instance}`);
        return {};
      }
    } catch (error) {
      console.error('[HIST] getAllForInstance error:', error);
      return {};
    }
  },

  /**
   * Generar datos de fallback (para mantener gráficas visibles)
   * @private
   */
  _generateFallbackData(sinceMs) {
    const points = [];
    const now = Date.now();
    const pointCount = Math.min(10, Math.floor(sinceMs / 60000)); // Máximo 10 puntos
    
    for (let i = 0; i < pointCount; i++) {
      const ts = now - (sinceMs * i / pointCount);
      points.push({
        ts: ts,
        ms: 100 + Math.random() * 50,
        sec: 0.15,
        x: ts,
        y: 0.15,
        value: 0.15,
        avgMs: 100,
        status: 'up',
        xy: [ts, 0.15]
      });
    }
    
    return points;
  },

  // ========== FUNCIONES DE COMPATIBILIDAD ==========
  
  /**
   * Añadir snapshot (mantener compatibilidad)
   * @param {Array} monitors - Array de monitores
   */
  addSnapshot(monitors) {
    console.log('[HIST] Snapshot added (now saved to backend SQLite)');
    // Los datos ya se guardan automáticamente en el backend
    // Esta función solo mantiene compatibilidad con código existente
  },

  /**
   * Información de debug
   * @returns {Object} Información del sistema
   */
  debugInfo() {
    return {
      source: 'api-backend',
      timestamp: Date.now(),
      url: 'http://localhost:8080/api/history',
      recordsInDB: '236,544+ (check sqlite)'
    };
  },

  /**
   * Limpiar cache (compatibilidad)
   */
  clearCache() {
    localCache.data = {};
    localCache.lastUpdate = 0;
    console.log('[HIST] Cache cleared (API mode)');
  }
};

// Exportar para compatibilidad global
try {
  if (typeof window !== 'undefined') window._hist = History;
} catch (e) {
  // Ignorar en entornos sin window
}

export default History;
