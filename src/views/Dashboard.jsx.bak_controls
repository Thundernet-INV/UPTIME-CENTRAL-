import { useEffect, useMemo, useRef, useState } from "react";

import Hero from "../components/Hero.jsx";
import AlertsBanner from "../components/AlertsBanner.jsx";
import Cards from "../components/Cards.jsx";
import InstanceDetail from "../components/InstanceDetail.jsx";
import SLAAlerts from "../components/SLAAlerts.jsx";
import InstanceCard from "../components/InstanceCard.jsx";
import MultiServiceView from "../components/MultiServiceView.jsx";

import { fetchAll, getBlocklist, saveBlocklist } from "../api.js";
import History from "../historyEngine.js";
import { notify } from "../utils/notify.js";

const SLA_CONFIG = { uptimeTarget: 99.9, maxLatencyMs: 800 };
const ALERT_AUTOCLOSE_MS = 10000;

// Variación de latencia por SERVICIO
const DELTA_ALERT_MS = 100; // umbral (ms)
const DELTA_COOLDOWN_MS = 60 * 1000; // cooldown por servicio (ms)
const DELTA_WINDOW = 5; // nº de valores para el promedio (por servicio)

/**
 * Ruteo por hash: #/sede/<instancia>, #/comparar
 * vacío -> home
 */
function getRoute() {
  const parts = (window.location.hash || "")
    .slice(1)
    .split("/")
    .filter(Boolean);

  if (parts[0] === "sede" && parts[1]) {
    return { name: "sede", instance: decodeURIComponent(parts[1]) };
  }

  if (parts[0] === "comparar") {
    return { name: "compare" };
  }

  return { name: "home" };
}

const keyFor = (i, n = "") => JSON.stringify({ i, n });

const fromKey = (k) => {
  try {
    return JSON.parse(k);
  } catch {
    return { i: "", n: "" };
  }
};

// Historial de RT para cálculo de variación
const lastRtHistory = { current: new Map() };

export default function Dashboard() {
  // ===== Playlist entre sedes =====
  const [autoPlay, setAutoPlay] = useState(false);
  const [autoPlayIndex, setAutoPlayIndex] = useState(0);

  // Toggle global de popups (notify)
  const [notificationsEnabled, setNotificationsEnabled] = useState(true);

  // ===== Estado base =====
  const [monitors, setMonitors] = useState([]);
  const [instances, setInstances] = useState([]);
  const [filters, setFilters] = useState({
    instance: "",
    type: "",
    q: "",
    status: "all",
  });
  const [hidden, setHidden] = useState(new Set());
  const [route, setRoute] = useState(getRoute());
  const [alerts, setAlerts] = useState([]);

  // ===== Ruteo por hash =====
  useEffect(() => {
    const onHash = () => setRoute(getRoute());
    window.addEventListener("hashchange", onHash);
    return () => window.removeEventListener("hashchange", onHash);
  }, []);

  // ===== Init: primer fetch + blocklist + snapshot =====
  const didInit = useRef(false);

  useEffect(() => {
    if (didInit.current) return;
    didInit.current = true;

    (async () => {
      try {
        const { instances, monitors } = await fetchAll();
        setInstances(instances);
        setMonitors(monitors);
        History.addSnapshot(monitors);

        try {
          const bl = await getBlocklist();
          setHidden(
            new Set(
              (bl?.monitors ?? []).map((k) => keyFor(k.instance, k.name))
            )
          );
        } catch {
          // ignorar errores de blocklist
        }
      } catch (e) {
        console.error(e);
      }
    })();
  }, []);

  // ===== Polling 5s + alertas DOWN + variación por servicio =====
  const lastStatus = useRef(new Map()); // key -> last status
  const lastRT = useRef(new Map()); // key -> last responseTime (ms)
  const lastDeltaAt = useRef(new Map()); // key -> last alert timestamp

  // Siembra inicial de lastRT/lastStatus la primera vez que llegan monitores
  useEffect(() => {
    const r1 = new Map();

