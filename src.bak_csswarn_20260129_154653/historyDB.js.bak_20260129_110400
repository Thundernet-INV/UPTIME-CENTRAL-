// historyDB.js — Snapshots en IndexedDB (retención 7 días) y utilitarios de consulta
const DB_NAME = 'kuma_history_v2';
const STORE   = 'snapshots';
const DB_VER  = 1;

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VER);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) {
        const os = db.createObjectStore(STORE, { keyPath: 'id', autoIncrement: true });
        os.createIndex('by_ts',  'ts');
        os.createIndex('by_key', 'key'); // instance::name
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror   = () => reject(req.error);
  });
}

async function addSnapshots(monitors, nowTs = Date.now()) {
  if (!Array.isArray(monitors) || !monitors.length) return;
  const db = await openDB();
  const tx = db.transaction(STORE, 'readwrite');
  const st = tx.objectStore(STORE);
  for (const m of monitors) {
    const rec = {
      ts: nowTs,
      instance: m.instance,
      name: m.info?.monitor_name || '',
      status: (m.latest?.status ?? null),
      responseTime: (m.latest?.responseTime ?? null),
      key: `${m.instance}::${m.info?.monitor_name || ''}`
    };
    st.add(rec);
  }
  await new Promise((res, rej) => { tx.oncomplete=res; tx.onerror=()=>rej(tx.error); });
  db.close();
}

async function pruneOlderThanDays(days=7) {
  const cutoff = Date.now() - days*24*3600*1000;
  const db = await openDB();
  const tx = db.transaction(STORE, 'readwrite');
  const st = tx.objectStore(STORE);
  const idx = st.index('by_ts');
  const req = idx.openCursor();
  await new Promise((resolve, reject) => {
    req.onsuccess = () => {
      const cur = req.result;
      if (!cur) return resolve();
      if (cur.value.ts < cutoff) {
        st.delete(cur.primaryKey);
        cur.continue();
      } else {
        resolve();
      }
    };
    req.onerror = () => reject(req.error);
  });
  await new Promise((res, rej) => { tx.oncomplete=res; tx.onerror=()=>rej(tx.error); });
  db.close();
}

async function getSeriesFor(key, sinceMs) {
  const since = Date.now() - Math.max(0, Number(sinceMs) || 0);
  const out = [];
  const db = await openDB();
  const tx = db.transaction(STORE, 'readonly');
  const st = tx.objectStore(STORE);
  const idx = st.index('by_key');
  const req = idx.openCursor(IDBKeyRange.only(key));
  await new Promise((resolve, reject) => {
    req.onsuccess = () => {
      const cur = req.result;
      if (!cur) return resolve();
      if (cur.value.ts >= since) out.push(cur.value);
      cur.continue();
    };
    req.onerror = () => reject(req.error);
  });
  db.close();
  return out;
}

async function getAllForInstance(instance, sinceMs = 24*3600*1000) {
  const since = Date.now() - Math.max(0, Number(sinceMs) || 0);
  const outMap = new Map(); // name -> array
  const db = await openDB();
  const tx = db.transaction(STORE, 'readonly');
  const st = tx.objectStore(STORE);
  const idx = st.index('by_ts');
  const req = idx.openCursor(IDBKeyRange.lowerBound(since));
  await new Promise((resolve, reject) => {
    req.onsuccess = () => {
      const cur = req.result;
      if (!cur) return resolve();
      const v = cur.value;
      if (v.instance === instance && v.ts >= since) {
        const arr = outMap.get(v.name) || [];
        arr.push(v);
        outMap.set(v.name, arr);
      }
      cur.continue();
    };
    req.onerror = () => reject(req.error);
  });
  db.close();
  const outObj = {};
  for (const [name, arr] of outMap) outObj[name] = arr;
  return outObj;
}

async function getAvgSeriesByInstance(instance, sinceMs = 24*3600*1000, bucketMs = 60*1000) {
  const since = Date.now() - Math.max(0, Number(sinceMs) || 0);
  const sum = new Map(); const count = new Map();
  const db = await openDB();
  const tx = db.transaction(STORE, 'readonly');
  const st = tx.objectStore(STORE);
  const idx = st.index('by_ts');
  const req = idx.openCursor(IDBKeyRange.lowerBound(since));
  await new Promise((resolve, reject) => {
    req.onsuccess = () => {
      const cur = req.result;
      if (!cur) return resolve();
      const v = cur.value;
      if (v.instance === instance && v.ts >= since && typeof v.responseTime === 'number') {
        const b = Math.floor(v.ts / bucketMs) * bucketMs;
        sum.set(b, (sum.get(b) || 0) + v.responseTime);
        count.set(b, (count.get(b) || 0) + 1);
      }
      cur.continue();
    };
    req.onerror = () => reject(req.error);
  });
  db.close();
  const out = [];
  for (const [b, s] of sum) out.push({ ts: b, avgMs: s / (count.get(b) || 1) });
  out.sort((a,b)=> a.ts - b.ts);
  return out;
}

export default {
  addSnapshots,
  pruneOlderThanDays,
  getSeriesFor,
  getAllForInstance,
  getAvgSeriesByInstance,
};
