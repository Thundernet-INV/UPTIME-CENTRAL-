// historyDB.js: snapshots en IndexedDB con retención de 7 días
const DB_NAME = 'kuma_history_v2';
const STORE = 'snapshots';
const DB_VER = 1;

function openDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VER);
    req.onupgradeneeded = (e) => {
      const db = req.result;
      if (!db.objectStoreNames.contains(STORE)) {
        const os = db.createObjectStore(STORE, { keyPath: 'id', autoIncrement: true });
        os.createIndex('by_ts', 'ts');
        os.createIndex('by_key', 'key'); // instance+name
      }
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function addSnapshots(monitors, nowTs = Date.now()) {
  if (!Array.isArray(monitors) || !monitors.length) return;
  const db = await openDB();
  const tx = db.transaction(STORE, 'readwrite');
  const st = tx.objectStore(STORE);
  for (const m of monitors) {
    const rec = {
      ts: nowTs,
      instance: m.instance,
      name: m.info?.monitor_name || '',
      status: (m.latest?.status ?? null),
      responseTime: (m.latest?.responseTime ?? null),
      key: `${m.instance}::${m.info?.monitor_name || ''}`
    };
    st.add(rec);
  }
  await new Promise((res, rej) => { tx.oncomplete=res; tx.onerror=()=>rej(tx.error); });
  db.close();
}

async function pruneOlderThanDays(days=7) {
  const cutoff = Date.now() - days*24*3600*1000;
  const db = await openDB();
  const tx = db.transaction(STORE, 'readwrite');
  const st = tx.objectStore(STORE);
  const idx = st.index('by_ts');
  const req = idx.openCursor();
  await new Promise((resolve, reject) => {
    req.onsuccess = () => {
      const cur = req.result;
      if (!cur) return resolve();
      if (cur.value.ts < cutoff) {
        st.delete(cur.primaryKey);
        cur.continue();
      } else {
        resolve();
      }
    };
    req.onerror = () => reject(req.error);
  });
  await new Promise((res, rej) => { tx.oncomplete=res; tx.onerror=()=>rej(tx.error); });
  db.close();
}

// Lectura simple (últimos N ms) – utilizable para sparkline si quieres
async function getSeriesFor(key, sinceMs) {
  const since = Date.now() - sinceMs;
  const out = [];
  const db = await openDB();
  const tx = db.transaction(STORE, 'readonly');
  const st = tx.objectStore(STORE);
  const idx = st.index('by_key');
  const range = IDBKeyRange.only(key);
  const req = idx.openCursor(range);
  await new Promise((resolve, reject) => {
    req.onsuccess = () => {
      const cur = req.result;
      if (!cur) return resolve();
      if (cur.value.ts >= since) out.push(cur.value);
      cur.continue();
    };
    req.onerror = () => reject(req.error);
  });
  db.close();
  return out;
}

export default {
  addSnapshots,
  pruneOlderThanDays,
  getSeriesFor,
};
