import React, { useEffect, useMemo, useRef } from "react";

/**
 * AutoPlayer v2
 * - En HOME: tras intervalSec abre la próxima sede.
 * - En SEDE: tras viewSec vuelve a HOME; al volver, HOME abre la próxima sede.
 * - Orden: "downFirst" o "alpha"; filtro "onlyIncidents"; loop.
 */
export default function AutoPlayer({
  enabled=false,
  intervalSec=10,
  viewSec=10,
  order="downFirst",
  onlyIncidents=false,
  loop=true,
  filteredAll=[],
  route,
  openInstance
}) {
  const idxRef = useRef(0);
  const timerRef = useRef(null);

  const instanceStats = useMemo(() => {
    const map = new Map();
    for (const m of filteredAll) {
      const it = map.get(m.instance) || { up:0, down:0, total:0 };
      if (m.latest?.status === 1) it.up++; else if (m.latest?.status === 0) it.down++;
      it.total++;
      map.set(m.instance, it);
    }
    return map;
  }, [filteredAll]);

  const playlist = useMemo(() => {
    let arr = Array.from(instanceStats.keys());
    if (onlyIncidents) arr = arr.filter(n => (instanceStats.get(n)?.down || 0) > 0);
    if (order === "downFirst") {
      arr.sort((a,b)=> (instanceStats.get(b)?.down||0) - (instanceStats.get(a)?.down||0) || a.localeCompare(b));
    } else {
      arr.sort((a,b)=> a.localeCompare(b));
    }
    return arr;
  }, [instanceStats, onlyIncidents, order]);

  // Mantener índice válido al cambiar el tamaño de la lista
  useEffect(() => { if (idxRef.current >= playlist.length) idxRef.current = 0; }, [playlist.length]);

  useEffect(() => {
    // limpiar timer previo
    if (timerRef.current) { clearTimeout(timerRef.current); timerRef.current = null; }
    if (!enabled || !playlist.length) return;

    if (route?.name === "home") {
      // Programar apertura de la próxima sede
      const goNext = () => {
        if (!playlist.length) return;
        if (idxRef.current >= playlist.length) {
          if (!loop) return;
          idxRef.current = 0;
        }
        const name = playlist[idxRef.current++];
        openInstance?.(name);
      };
      timerRef.current = setTimeout(goNext, Math.max(3, intervalSec) * 1000);
    } else if (route?.name === "sede") {
      // Permanecer en la sede viewSec y regresar a HOME para continuar
      const backHome = () => { window.location.hash = ""; };
      timerRef.current = setTimeout(backHome, Math.max(3, viewSec) * 1000);
    }

    return () => { if (timerRef.current) { clearTimeout(timerRef.current); timerRef.current=null; } };
  }, [enabled, intervalSec, viewSec, route?.name, playlist.length, loop, openInstance]);

  return null;
}
