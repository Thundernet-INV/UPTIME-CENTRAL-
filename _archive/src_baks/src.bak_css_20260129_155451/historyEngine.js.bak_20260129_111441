import DB from './historyDB';

// Helper: normaliza un punto con múltiples alias (ms y segundos)
function mkPoint(ts, ms){
  const sec = (typeof ms === 'number') ? (ms/1000) : null;
  return {
    ts,
    // valores en segundos (lo que suelen graficar)
    y: sec, value: sec, sec,
    // valores en ms (por si algún lugar lo usa)
    ms, avgMs: ms,
    // par para libs que aceptan tuple
    xy: [ts, sec],
  };
}

const History = {
  // Persistencia + poda (7d)
  addSnapshot(monitors) {
    DB.addSnapshots(monitors).catch(()=>{});
    DB.pruneOlderThanDays(7).catch(()=>{});
  },

  // Serie cruda por monitor
  async getSeriesForMonitor(instance, name, sinceMs = 24*3600*1000) {
    const key = `${instance}::${name || ''}`;
    const rows = await DB.getSeriesFor(key, sinceMs);
    return rows
      .filter(r => typeof r.responseTime === 'number')
      .map(r => mkPoint(r.ts, r.responseTime));
  },

  // Serie promedio por monitor (buckets)
  async getAvgSeriesForMonitor(instance, name, sinceMs = 24*3600*1000, bucketMs = 60*1000) {
    const samples = await History.getSeriesForMonitor(instance, name, sinceMs);
    if (!samples.length) return [];
    const sum = new Map(), count = new Map();
    for (const s of samples) {
      const b = Math.floor(s.ts / bucketMs) * bucketMs;
      const ms = s.ms ?? (s.sec*1000);
      sum.set(b, (sum.get(b) || 0) + ms);
      count.set(b, (count.get(b) || 0) + 1);
    }
    const out = [];
    for (const [b, s] of sum) {
      const avgMs = s / (count.get(b) || 1);
      out.push(mkPoint(b, avgMs));
    }
    out.sort((a,b)=> a.ts - b.ts);
    return out;
  },

  // Objeto { nombreMonitor: muestras[] } para una instancia
  async getAllForInstance(instance, sinceMs = 24*3600*1000) {
    const obj = await DB.getAllForInstance(instance, sinceMs);
    const out = {};
    for (const [name, arr] of Object.entries(obj || {})) {
      out[name] = (arr || [])
        .filter(r => typeof r.responseTime === 'number')
        .map(r => mkPoint(r.ts, r.responseTime));
    }
    return out;
  },

  // Serie promedio por instancia (array)
  async getAvgSeriesByInstance(instance, sinceMs = 24*3600*1000, bucketMs = 60*1000) {
    const arr = await DB.getAvgSeriesByInstance(instance, sinceMs, bucketMs);
    // mapear a forma compatible
    return (arr || []).map(p => mkPoint(p.ts, p.avgMs));
  },
};

export default History;
