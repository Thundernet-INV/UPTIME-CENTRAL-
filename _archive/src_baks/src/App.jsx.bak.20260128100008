import { useEffect, useMemo, useState, useRef } from "react";
import Cards from "./components/Cards.jsx";
import Filters from "./components/Filters.jsx";
import ServiceGrid from "./components/ServiceGrid.jsx";
import MonitorsTable from "./components/MonitorsTable.jsx";
import InstanceDetail from "./components/InstanceDetail.jsx";
import SLAAlerts from "./components/SLAAlerts.jsx";
import AutoPlayControls from "./components/AutoPlayControls.jsx";
import AlertsBanner from "./components/AlertsBanner.jsx";
import { fetchAll, getBlocklist, saveBlocklist } from "./api.js";
import History from "./historyEngine.js";

const SLA_CONFIG = { uptimeTarget: 99.9, maxLatencyMs: 800 };
const ALERT_AUTOCLOSE_MS = 10000;

function getRoute() {
  const parts = (window.location.hash || "").slice(1).split("/").filter(Boolean);
  if (parts[0] === "sede" && parts[1]) return { name: "sede", instance: decodeURIComponent(parts[1]) };
  return { name: "home" };
}
const keyFor = (instance, name="") => JSON.stringify({i:instance,n:name});
const fromKey = (k) => { try { return JSON.parse(k); } catch { return {i:"",n:""} } };

export default function App() {
const [autoRun, setAutoRun] = useState(false);
const [autoIntervalSec, setAutoIntervalSec] = useState(10);
const [autoOrder, setAutoOrder] = useState("downFirst");
const [autoOnlyIncidents, setAutoOnlyIncidents] = useState(false);
const [autoLoop, setAutoLoop] = useState(true);
const [autoViewSec, setAutoViewSec] = useState(10);   //  << NECESARIO
  const [monitors, setMonitors]   = useState([]);
  const [instances, setInstances] = useState([]);
  const [filters, setFilters]     = useState({ instance:"", type:"", q:"", status:"all" });
  const [hidden, setHidden]       = useState(new Set());
  const [view, setView]           = useState("grid");
  const [route, setRoute]         = useState(getRoute());
  const [alerts, setAlerts]       = useState([]);

  useEffect(() => { const onHash = () => setRoute(getRoute()); window.addEventListener("hashchange", onHash); return () => window.removeEventListener("hashchange", onHash); }, []);

  // init
  const didInit = useRef(false);
  useEffect(() => {
    if (didInit.current) return; didInit.current = true;
    (async () => {
      try {
        const { instances, monitors } = await fetchAll();
        setInstances(instances); setMonitors(monitors);
        History.addSnapshot(monitors);
        const bl = await getBlocklist();
        const set = new Set((bl?.monitors ?? []).map(k => keyFor(k.instance, k.name)));
        setHidden(set);
      } catch (e) { console.error(e); }
    })();
  }, []);

  // Detectar DOWN 1->0 + snapshots 5s
  const lastStatus = useRef(new Map());
  useEffect(() => { const m = new Map(); for (const x of monitors) m.set(keyFor(x.instance, x.info?.monitor_name), x.latest?.status ?? 1); lastStatus.current = m; }, []);
  useEffect(() => {
    let stop = false;
    async function loop() {
      if (stop) return;
      try {
        const { instances, monitors } = await fetchAll();
        setInstances(instances); setMonitors(monitors);
        History.addSnapshot(monitors);
        const prev = lastStatus.current, next = new Map(), newDowns=[];
        for (const m of monitors) {
          const k = keyFor(m.instance, m.info?.monitor_name), st = m.latest?.status ?? 1, was = prev.get(k);
          if (was === 1 && st === 0) newDowns.push({ id:k, instance:m.instance, name:m.info?.monitor_name, ts:Date.now() });
          next.set(k, st);
        }
        lastStatus.current = next;
        if (newDowns.length) setAlerts(prevA => {
          const ids = new Set(prevA.map(a=>a.id)); const add = newDowns.filter(a=>!ids.has(a.id)); return [...prevA, ...add];
        });
        setAlerts(prevA => prevA.filter(a => next.get(a.id) === 0));
      } catch {}
      setTimeout(loop, 5000);
    }
    loop(); return () => { stop = true; };
  }, []);

  // baseMonitors para header (sin estado)
  const baseMonitors = useMemo(() => monitors.filter(m => {
    if (filters.instance && m.instance !== filters.instance) return false;
    if (filters.type && m.info?.monitor_type !== filters.type) return false;
    if (filters.q) {
      const hay = `${m.info?.monitor_name ?? ""} ${m.info?.monitor_url ?? ""}`.toLowerCase();
      if (!hay.includes(filters.q.toLowerCase())) return false;
    }
    return true;
  }), [monitors, filters.instance, filters.type, filters.q]);

  // header counts
  const headerCounts = useMemo(() => {
    const up = baseMonitors.filter(m => m.latest?.status === 1).length;
    const down = baseMonitors.filter(m => m.latest?.status === 0).length;
    const total = baseMonitors.length;
    const rts = baseMonitors.map(m => m.latest?.responseTime).filter(v => v != null);
    const avgMs = rts.length ? Math.round(rts.reduce((a,b)=>a+b,0)/rts.length) : null;
    return { up, down, total, avgMs };
  }, [baseMonitors]);

  // estado efectivo
  const effectiveStatus = filters.status;
  function setStatus(s){ setFilters(p => ({ ...p, status:s })); }

  // monitores visibles (con estado)
  const filteredAll = useMemo(() => baseMonitors.filter(m => {
    if (effectiveStatus === "up"   && m.latest?.status !== 1) return false;
    if (effectiveStatus === "down" && m.latest?.status !== 0) return false;
    return true;
  }), [baseMonitors, effectiveStatus]);

  const visible = filteredAll.filter(m => !hidden.has(keyFor(m.instance, m.info?.monitor_name)));

  // Instancias Ãºnicas del subconjunto filtrado
  const instanceStats = useMemo(() => {
    const map = new Map();
    for (const m of filteredAll) {
      const it = map.get(m.instance) || { up:0, down:0, total:0 };
      if (m.latest?.status === 1) it.up++; else if (m.latest?.status === 0) it.down++;
      it.total++;
      map.set(m.instance, it);
    }
    return map;
  }, [filteredAll]);

  const playlist = useMemo(() => {
    let arr = Array.from(instanceStats.keys());
    if (autoOnlyIncidents) {
      arr = arr.filter(name => (instanceStats.get(name)?.down || 0) > 0);
    }
    if (autoOrder === "downFirst") {
      arr.sort((a,b)=> (instanceStats.get(b)?.down||0) - (instanceStats.get(a)?.down||0) || a.localeCompare(b));
    } else {
      arr.sort((a,b)=> a.localeCompare(b));
    }
    return arr;
  }, [instanceStats, autoOnlyIncidents, autoOrder]);


  // hidden mgmt
  async function persistHidden(next) {
    const arr = [...next].map(k => { const {i,n}=fromKey(k); return {instance:i,name:n}; });
    await saveBlocklist({ monitors: arr }); setHidden(next);
  }
  function onHide(i,n){ const s=new Set(hidden); s.add(keyFor(i,n)); persistHidden(s); }
  function onUnhide(i,n){ const s=new Set(hidden); s.delete(keyFor(i,n)); persistHidden(s); }
  function onHideAll(instance){
    const s = new Set(hidden);
    filteredAll.filter(m=>m.instance===instance).forEach(m=>s.add(keyFor(m.instance, m.info?.monitor_name)));
    persistHidden(s);
  }
  async function onUnhideAll(instance){
    const bl = await getBlocklist(); const nextArr = (bl?.monitors ?? []).filter(k => k.instance !== instance);
    await saveBlocklist({ monitors: nextArr }); setHidden(new Set(nextArr.map(k=>keyFor(k.instance,k.name))));
  }
  function openInstance(name){ window.location.hash = "/sede/" + encodeURIComponent(name); }

  return (
    <div className="container" data-route={route.name}>
      <h1>Uptime Central</h1>
      <AlertsBanner alerts={alerts} onClose={(id)=>setAlerts(a=>a.filter(x=>x.id!==id))} autoCloseMs={ALERT_AUTOCLOSE_MS}/>
      <Cards counts={headerCounts} status={effectiveStatus} onSetStatus={setStatus} />
      <div className="controls">
        {/* Controles de autoplay (playlist) */}
        <AutoPlayControls
          running={autoRun}
          onToggle={()=>setAutoRun(v=>!v)}
          intervalSec={autoIntervalSec} setIntervalSec={setAutoIntervalSec}
          order={autoOrder} setOrder={setAutoOrder}
          onlyIncidents={autoOnlyIncidents} setOnlyIncidents={setAutoOnlyIncidents}
          loop={autoLoop} setLoop={setAutoLoop}
          viewSec={autoViewSec} setViewSec={setAutoViewSec}
        />
        <Filters monitors={monitors} value={filters} onChange={setFilters} />
        {route.name!=="sede" && (
          <div className="global-toggle" style={{ display:"flex", gap:8 }}>
            <button type="button" className={`btn tab ${view==="grid"?"active":""}`}  aria-pressed={view==="grid"}  onClick={()=>setView("grid")}>Grid</button>
            <button type="button" className={`btn tab ${view==="table"?"active":""}`} aria-pressed={view==="table"} onClick={()=>setView("table")}>Tabla</button>
          </div>
        )}
      </div>
      <SLAAlerts monitors={visible} config={SLA_CONFIG} onOpenInstance={openInstance} />
      {route.name==="sede" ? (
        <div className="container">
          <InstanceDetail instanceName={route.instance} monitorsAll={filteredAll} hiddenSet={hidden}
            onHide={onHide} onUnhide={onUnhide} onHideAll={onHideAll} onUnhideAll={onUnhideAll}/>
        </div>
      ) : view==="grid" ? (
        <ServiceGrid monitorsAll={filteredAll} hiddenSet={hidden} onHideAll={onHideAll} onUnhideAll={onUnhideAll} onOpen={openInstance} />
      ) : (
        <MonitorsTable monitors={visible} hiddenSet={hidden} onHide={onHide} onUnhide={onUnhide} slaConfig={SLA_CONFIG}/>
      )}
    </div>
  );
}
