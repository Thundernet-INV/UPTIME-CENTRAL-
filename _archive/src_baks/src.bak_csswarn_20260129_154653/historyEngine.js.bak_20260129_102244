// Simple history engine (localStorage) – snapshots de monitores + utilidades de limpieza
const KEY = "kuma_history_snapshots_v1";
const MAX = 500;
const SPARK_POINTS = 120;

function load(){ try { return JSON.parse(localStorage.getItem(KEY) || "[]"); } catch { return []; } }
function save(a){ try { localStorage.setItem(KEY, JSON.stringify(a)); } catch {} }
function now(){ return Date.now(); }

// === Núcleo estadístico ===
function avgLatencyForInstance(ms, instance) {
  const arr = ms.filter(m => m.instance === instance)
                .map(m => m.latest?.responseTime)
                .filter(v => typeof v === "number" && isFinite(v));
  if (!arr.length) return null;
  return Math.round(arr.reduce((a,b)=>a+b,0)/arr.length);
}
function downCountForInstance(ms, instance) {
  return ms.filter(m => m.instance === instance && m.latest?.status === 0).length;
}
function findMonitor(ms, instance, name) {
  const n = (name||'').toLowerCase().trim();
  return ms.find(m => m.instance===instance && (m.info?.monitor_name||'').toLowerCase().trim()===n);
}

const History = {
  addSnapshot(monitors) {
    const s = load(); s.push({ t: now(), monitors });
    while (s.length > MAX) s.shift();
    save(s);
  },

  // === Series para UI ===
  getAvgSeriesByInstance(instance, maxPoints = SPARK_POINTS) {
    const s = load(), xs=[], ys=[];
    for (const snap of s){ xs.push(snap.t); ys.push(avgLatencyForInstance(snap.monitors, instance)); }
    const start=Math.max(0,xs.length-maxPoints); return { t: xs.slice(start), v: ys.slice(start) };
  },
  getDownsSeriesByInstance(instance, maxPoints = SPARK_POINTS) {
    const s = load(), xs=[], ys=[];
    for (const snap of s){ xs.push(snap.t); ys.push(downCountForInstance(snap.monitors, instance)); }
    const start=Math.max(0,xs.length-maxPoints); return { t: xs.slice(start), v: ys.slice(start) };
  },
  getSeriesForMonitor(instance, monitorName, maxPoints = SPARK_POINTS) {
    const s = load(), xs=[], ys=[];
    for (const snap of s) {
      const m = findMonitor(snap.monitors, instance, monitorName);
      xs.push(snap.t);
      ys.push(typeof m?.latest?.responseTime === "number" ? m.latest.responseTime : null);
    }
    const start=Math.max(0,xs.length-maxPoints); return { t: xs.slice(start), v: ys.slice(start) };
  },
  getAllForInstance(instance, maxPoints = MAX) {
    const lat = this.getAvgSeriesByInstance(instance, maxPoints);
    const dwn = this.getDownsSeriesByInstance(instance, maxPoints);
    return { lat, dwn };
  },

  // === AUTO-LIMPIEZA: purgar monitores ausentes ===
  /**
   * Purga snapshots históricos eliminando monitores cuyo (instance,name) ya no existe en "liveSet"
   * @param {Set<string>} liveSet - claves JSON.stringify({i,n}) de monitores vivos
   */
  purgeMissing(liveSet) {
    const s = load();
    const cleaned = s.map(snap => {
      const ms = (snap.monitors || []).filter(m => {
        const key = JSON.stringify({ i: m.instance, n: m.info?.monitor_name });
        return liveSet.has(key);
      });
      return { t: snap.t, monitors: ms };
    });
    save(cleaned);
  }
};

export default History;
